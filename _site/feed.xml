<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.2.1">Jekyll</generator><link href="https://mdrakos.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://mdrakos.github.io/" rel="alternate" type="text/html" /><updated>2017-11-03T08:39:40-07:00</updated><id>https://mdrakos.github.io/</id><title>Mike Drakos</title><subtitle>A portfolio website for Mike Drakos</subtitle><author><name>Mike Drakos</name><email>mike.drakos@gmail.com</email></author><entry><title>Design Patterns - Part 1</title><link href="https://mdrakos.github.io/Design-Patterns/" rel="alternate" type="text/html" title="Design Patterns - Part 1" /><published>2017-08-15T00:00:00-07:00</published><updated>2017-08-15T00:00:00-07:00</updated><id>https://mdrakos.github.io/Design Patterns</id><content type="html" xml:base="https://mdrakos.github.io/Design-Patterns/">&lt;p&gt;Part of my work for an undergraduate thesis is to build an application based on graphlets. This application parses a file to generate a graph then uses the graph to create graphlet degree vectors (GDV) for each node. Once that initial step is completed it uses the GDVs to put together a matrix and perform other statistical analysis.&lt;/p&gt;

&lt;p&gt;While writing this application I’ve run into design issues. Initially everything was just methods. I wrote it this way in order to ensure everything was working; at the time I didn’t realize how much extra work I was creating for myself. I’ve refactored all of the code once so I’m using objects and not repeating some code unnecessarily. However, now when I need to add features, like being able to process different types of graphs, (directed, weighted, signed, etc…) I’m having to rewrite base methods with more logic. This work is not a very efficient use of my time and overall it’s a bad practice. This is why I’ve picked up a textbook on design patterns.&lt;/p&gt;

&lt;p&gt;Improving a current application I’m working on is one reason to study design patterns, another is to become a better programmer in general. Designing a program with efficiency, modularity, and reusability in mind is difficult. Modularity is a feature of object oriented programming that makes it great. If we strike a proper balance between specific and general when designing our system we can use our solution again when a similar problem arises.&lt;/p&gt;

&lt;p&gt;Throughout a degree in Computer Science you learn many of the object oriented programming (OOP) tools like classes, interfaces, inheritance, diagrams for relationships and interaction, and many more. However, how all these tools can work together to achieve a simple and general solution isn’t a focus of the curriculum. This isn’t really because of any deficiency in the CS program, it’s more that there is so much material to cover in four years. When it comes to OOP specifically time has to be spent reinforcing the concepts. Being familiar with these concepts equips us to tackle something like design patterns when we’re ready or when we realize that we’re writing the same method for the 4th time and want to find a better way.&lt;/p&gt;

&lt;p&gt;When picking up the textbook for the first time I skimmed through a few of the chapters and started to wonder if I’m ready to take on this topic. Some of the ideas were not clear to me right away and others never became clear. My assumption is that I will have to revisit this topic many times throughout my career. There are some videos on the Google sponsored YouTube channel about interviewing at Google. In the coding interview video it’s mentioned that if you have 5+ years of experience in the industry you could be asked system design questions. While I may not get the full benefit from this textbook at least now I will have a better idea of system design and maybe even improve my graphlet program.&lt;/p&gt;

&lt;p&gt;So with that out of the way, what are design patterns? They are patterns that come up again and again when designing a system and have proven to be effective and reusable. (I was going to write simple but I’m not convinced of that yet). In a sense they capture the experience of those who have designed many systems. The textbook is organized as a catalogue of design patterns that can be used as a solution when a similar problem arises. Experienced programmers have noticed these patterns showing up again and again and have tested these solutions in production code.&lt;/p&gt;

&lt;p&gt;Rather than getting into the specific details I will provide some real world examples, since design patterns occur everywhere. Consider construction, when building a structure like a bridge, house, or road the solution at the core of the problem is the same and is used over and over again. We can use the core solution many times and still not solve the problem the same way twice. Another example is found in storytelling. Most movies, books, and songs tell the same old stories over and over again but in very different ways.&lt;/p&gt;

&lt;p&gt;That’s the general idea, or what I’ve been able to gather. I know I haven’t gone into much technical detail here but I find these abstractions useful before diving into something new. Next time I write about design patterns I will try to write a more concrete definition and give an example. I still think this general idea is fairly exciting and promises to improve your code at any level.&lt;/p&gt;</content><author><name>Mike Drakos</name><email>mike.drakos@gmail.com</email></author><summary>Part of my work for an undergraduate thesis is to build an application based on graphlets. This application parses a file to generate a graph then uses the graph to create graphlet degree vectors (GDV) for each node. Once that initial step is completed it uses the GDVs to put together a matrix and perform other statistical analysis.</summary></entry><entry><title>Enjoy Learning</title><link href="https://mdrakos.github.io/Enjoy-Learning/" rel="alternate" type="text/html" title="Enjoy Learning" /><published>2017-08-08T00:00:00-07:00</published><updated>2017-08-08T00:00:00-07:00</updated><id>https://mdrakos.github.io/Enjoy Learning</id><content type="html" xml:base="https://mdrakos.github.io/Enjoy-Learning/">&lt;p&gt;Recently I introduced a friend to &lt;a href=&quot;www.freecodecamp.com&quot;&gt;freecodecamp.com&lt;/a&gt;. Check it out if you haven’t, it’s a wonderful introduction to web development that I’m currently working through. My friend has a good job, and he makes a difference to the people he works with. However, eventually some of us get to a point in our careers where we begin to question what we’re doing and if we want to keep doing it for the rest of our lives. A similar line of questioning is what led me to pursue a CS degree, so when I see those close to me asking the same questions I always mention CS as a possible option.&lt;/p&gt;

&lt;p&gt;The introduction to freeCodeCamp was quick and straightforward. I showed him around the different certifications (front end, back end, and data visualization) and what the challenges looked like. I also showed him some completed projects that I’ve put on my portfolio site. After the introduction, and a few quick questions, something happened that I didn’t expect. My friend started listing off a bunch of ideas he had for websites. Some of these ideas were plays off of my completed projects, others were brand new and surprisingly creative. This might not seem too surprising but I was taken aback by it. I’m not a very creative person and I have a lot of trouble coming up with project ideas. I’ve spent hours trying to come up with something unique just to give up and pursue a project I’ve found on the internet. Now, here is my friend with 3 to 4 great ideas in under 2 minutes! In that moment I was pretty hard on myself for my lack of creativity, but over the next day or so I gained more insight into why I may find it hard to come up with new ideas.&lt;/p&gt;

&lt;p&gt;One of the traits of programming, and web development in particular, is how quickly the technology evolves. In 2016 I completed a project course with a team. We created an android app using Ionic and Angular 2. Today, after some googling, I found information on Ionic 3 and Angular 4. Technology evolves and it evolves quickly. As programmers we are expected to evolve with the technology. The more experience we have with the lastest popular framework the better our portfolios and resumes will look and the more likely we are to get an exciting and challenging job. Multiple frameworks and languages also do the same tasks so we have to choose a few to learn as it seems almost impossible to know them all. This quick evolution and variety is intimidating to me as someone who is starting out in a new career. I feel the pressure to learn a new framework when I read about it, or when I hear that one framework is better than another for a specific task. I question myself after spending an hour on jQuery and wonder if I should have spent that time learning React. This pursuit plays a role in stifling creativity. It’s necessary for technology to evolve and for us to constantly be learning, but it is also valuable to take some time with our current set of tools before moving on. If we are constantly pushing ourselves to learn that new framework or language we take time away from using our current tools to build things that are meaningful to us.&lt;/p&gt;

&lt;p&gt;The balance between learning new technologies and spending time with the ones we already know is delicate. We have to push ourselves to learn and go with the trends of the industry. As someone who is finally breaking into the job market and looking for my first job in the industry this push is strong. I’ve been trying to learn as much as I can over the last year in preparation for work. Thinking about this experience with my friend I started to ask myself, “What’s more important on a resume? Stating you know or have experience with so many different technologies or having some unique and creative projects with only a few?”&lt;/p&gt;

&lt;p&gt;I’ve known a lot of musicians who play in bands of various different genres. Those who played in metal bands (I’m not sure why) seem to love buying new gear. A lot of them are always looking for a new amp, compressor, guitar, pedals or whatever. I’ve seen a few of my friends spend more time on the internet looking at new gear and planning their setup than they do actually practicing and playing. This isn’t to say that these musicians failed or made terrible music, but you have to wonder if it impacted their progress. I’ve also known musicians who could care less about gear. They play on an old beat up acoustic and produce some amazingly creating stuff. As programmers we have to be able to asses how much chasing that new piece of gear will cost. We should ask if we can still express ourselves and our ideas with our current set of tools.&lt;/p&gt;

&lt;p&gt;There is no answer in this article, because I don’t have one, and because I don’t think one really exists. If you’re a programmer you shouldn’t stop learning about new technology. You should also learn to use your tools effectively. My main take away from this experience is that I simply need to enjoy the journey of learning to code more than I have been. My friend is still going through freeCodeCamp and he’s come up with some more great ideas that he wants to build with just HTML, CSS and a sprinkle of JS. That’s all you need to build something great if you have the patience and dedication to see what you can accomplish.&lt;/p&gt;</content><author><name>Mike Drakos</name><email>mike.drakos@gmail.com</email></author><summary>Recently I introduced a friend to freecodecamp.com. Check it out if you haven’t, it’s a wonderful introduction to web development that I’m currently working through. My friend has a good job, and he makes a difference to the people he works with. However, eventually some of us get to a point in our careers where we begin to question what we’re doing and if we want to keep doing it for the rest of our lives. A similar line of questioning is what led me to pursue a CS degree, so when I see those close to me asking the same questions I always mention CS as a possible option.</summary></entry><entry><title>Update Post</title><link href="https://mdrakos.github.io/Update/" rel="alternate" type="text/html" title="Update Post" /><published>2016-09-26T00:00:00-07:00</published><updated>2016-09-26T00:00:00-07:00</updated><id>https://mdrakos.github.io/Update</id><content type="html" xml:base="https://mdrakos.github.io/Update/">&lt;p&gt;This website was created as a way for me to show what I’ve worked on
and put down some thoughts. After playing
around with jekyll for a few hours I am starting to see the potential and I’m
looking forward to working more with it.&lt;/p&gt;

&lt;p&gt;Hopefully I can say up to date with projects I push to my personal github and leave
my thoughts as I work away at them!&lt;/p&gt;</content><author><name>Mike Drakos</name><email>mike.drakos@gmail.com</email></author><summary>This website was created as a way for me to show what I’ve worked on
and put down some thoughts. After playing
around with jekyll for a few hours I am starting to see the potential and I’m
looking forward to working more with it.</summary></entry><entry><title>Test Post</title><link href="https://mdrakos.github.io/Test-Post/" rel="alternate" type="text/html" title="Test Post" /><published>2016-09-26T00:00:00-07:00</published><updated>2016-09-26T00:00:00-07:00</updated><id>https://mdrakos.github.io/Test-Post</id><content type="html" xml:base="https://mdrakos.github.io/Test-Post/">&lt;p&gt;This is a test post.&lt;/p&gt;</content><author><name>Mike Drakos</name><email>mike.drakos@gmail.com</email></author><summary>This is a test post.</summary></entry></feed>
